#ifndef __SLTP_MANAGER_MQH__
#define __SLTP_MANAGER_MQH__

//--------------------------------------------------
// Calculate SL / TP with stop-level protection
//--------------------------------------------------
bool CalculateSLTP(
   const string symbol,
   ENUM_ORDER_TYPE orderType,
   int atrPeriod,
   double atrMultiplier,
   double rrMultiplier,
   double &sl,
   double &tp
)
{
   // --- Prices ---
   double bid = SymbolInfoDouble(symbol, SYMBOL_BID);
   double ask = SymbolInfoDouble(symbol, SYMBOL_ASK);
   double point = SymbolInfoDouble(symbol, SYMBOL_POINT);

   // --- Minimum stop distance (points â†’ price) ---
   int stopLevelPoints = (int)SymbolInfoInteger(symbol, SYMBOL_TRADE_STOPS_LEVEL);
   double minStop = stopLevelPoints * point;

   // --- ATR ---
   int atrHandle = iATR(symbol, PERIOD_M1, atrPeriod);
   if(atrHandle == INVALID_HANDLE)
      return false;

   double atrBuf[];
   if(CopyBuffer(atrHandle, 0, 0, 1, atrBuf) <= 0)
   {
      IndicatorRelease(atrHandle);
      return false;
   }
   IndicatorRelease(atrHandle);

   double atr = atrBuf[0];
   if(atr <= 0)
      return false;

   // --- Raw distances ---
   double slDist = atr * atrMultiplier;
   double tpDist = slDist * rrMultiplier;

   // --- Enforce minimum stop distance ---
   if(slDist < minStop)
      slDist = minStop * 1.1;

   if(tpDist < minStop)
      tpDist = minStop * 1.1;

   // --- Calculate SL / TP ---
   if(orderType == ORDER_TYPE_BUY)
   {
      sl = bid - slDist;
      tp = ask + tpDist;
   }
   else
   {
      sl = ask + slDist;
      tp = bid - tpDist;
   }

   // --- Normalize ---
   int digits = (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS);
   sl = NormalizeDouble(sl, digits);
   tp = NormalizeDouble(tp, digits);

   return true;
}

#endif
